#文件记录锁

https://www.cnblogs.com/xuyh/p/3278881.html

https://blog.csdn.net/rl529014/article/details/51336161

https://blog.csdn.net/qq_31108501/article/details/52877384?locationNum=8&fps=1

【锁的实现原理】
https://blog.csdn.net/bytxl/article/details/41309753

##理解

    - 多用户多任务操作系统中非常重要的一个内容就是文件锁。用户在更新文件时，期望可以使用某种机制，防止两种进程同时更新文件同一区域而造成丢失，或者防止文件内容在未更新完毕时被读取等并发引起的问题，这种机制就是文件锁。

    - 进程在操作文件期间，可以使用文件锁，锁定文件中的敏感部分，防止其他进程越权操作该部分数据。函数fcntl提供了对文件任意区域置锁的能力，既可以锁住全部文件，又可以锁住文件的部分记录，故文件锁又成为"记录锁".

    - 根据文件锁的访问方式，可以区分读锁和写锁两种。读锁又名共享锁，它用来【防止进程读取的文件记录被更改】。文件记录可以同时设置多个读锁，但当有一个读锁存在时，就不能在该记录出设置写锁。

    - 写锁又名互斥锁，它用来保证文件更改记录时不被干扰，确保文件一致性和完整性，防止写丢失或读"脏"数据。文件记录一旦设置了写锁，就不能再设置任意锁，除非写锁释放。

    - 文件记录在同一时刻，可以设置多个读锁，单仅能设置一个写锁，并且读、写不能不能同时存在。
    
    - 函数fcntl专用于锁操作时，其原型为：
        int fcntl(int fildes,int cmd,struct flock *arg);
        其中，结构flock用于描述文件锁的信息，定义于"fcntl.h"中，如下表示：
        
    - 文件锁最典型的应用于两个方面：
        【一个锁定文件中的临界数据】，比如并发投票时文件记录的投票数; 
        【二是利用具有互斥性质的写锁，实现进程的并发控制】
    
##文件锁实现的原理

    - Unix文件锁是在共享索引节点共享文件的情况下设计的，因此与锁机制相关的内核数据结构主要有【虚拟索引节点(V-node)】、【系统打开文件表】、【进程打开文件表】等数据表项。
    
    - 其中【V-node】中的索引节点(i-node)中含有一个指向【锁链表的首指针】，
    该锁链表主要由对文件所加的全部的锁通过指针钩链而成。只要进程为文件或区域加锁成功，内核就创建锁结构file_lock，并根据用户设定的参数初始化后将其插入锁链表flock中。flock是锁存在的唯一标志，也是内核感知、管理及控制文件锁的主要依据，其结构和成员参见下面的struct flock。
    
##建议锁和强制锁

    - Unix文件锁根据实现机制的不同，又可分为建议锁和强制锁两种类型。
    
    - 【建议锁由应用层实现】，内核只为用户提供程序接口，并不参与锁的控制和协调，也不对读写操作做内部检查和强制保护，也就是说，如果有进程不遵守“游戏规则”，不检查目标文件是否已经由别的进程加了锁就往其中写入数据，那么内核是不会加以阻拦的。因此，劝告锁并不能阻止进程对文件的访问，而只能依靠各个进程在访问文件之前检查该文件是否已经被其他进程加锁来实现并发控制。进程需要事先对锁的状态做一个约定，并根据锁的当前状态和相互关系来确定其他进程是否能对文件执行指定的操作。从这点上来说，劝告锁的工作方式与使用信号量保护临界区的方式非常类似。
    
    - 【强制锁则由内核强制实施】，每当有进程调用read或write时，内核都要检查读写操作是否与已加的锁冲突，如果冲突，阻塞方式下该进程将被阻塞直到锁被释放，非阻塞方式下系统将立即以错误返回。显然，使用强制锁来控制对已锁文件或文件区域的访问，是更安全可靠的同步形式，适用于网络连接、终端或串并行端口之类须独占使用的设备文件，因为对用户都可读的文件加一把强制读锁，就能使其他人不能再写该文件，从而保证了设备的独占使用。
    
    - 由于强制锁运行在内核空间，处理机从用户空间切换到内核空间，系统开销大，影响性能，所以应用程序很少使用。
    建议锁开销小，可移植性好，符合POSIX标准的文件锁实现，在【数据库系统中】应用广泛，特别是当多个进程交叉读写文件的不同部分时，建议锁有更好的并行性和实时性。  